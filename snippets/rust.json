{
	"2sat": {
		"body": [
			"struct TwoSat {",
			"    n: u32,",
			"    graph: Graph<()>,",
			"}",
			"",
			"impl TwoSat {",
			"    fn new(n: u32, clause_num: u32) -> Self {",
			"        Self {",
			"            n,",
			"            graph: Graph::new(n << 1, clause_num << 1),",
			"        }",
			"    }",
			"",
			"    fn judge(f: bool, a: u32, b: u32) -> u32 {",
			"        if f {",
			"            a",
			"        } else {",
			"            b",
			"        }",
			"    }",
			"",
			"    fn add_clause(&mut self, i: u32, f: bool, j: u32, g: bool) {",
			"        self.graph.add_edge(",
			"            (i << 1) + Self::judge(f, 0, 1),",
			"            (j << 1) + Self::judge(g, 1, 0),",
			"            (),",
			"        );",
			"        self.graph.add_edge(",
			"            (j << 1) + Self::judge(g, 0, 1),",
			"            (i << 1) + Self::judge(f, 1, 0),",
			"            (),",
			"        );",
			"    }",
			"",
			"    fn solve(self) -> Option<Vec<bool>> {",
			"        let mut answer = vec![false; self.n as usize];",
			"",
			"        let scc = SCC::new(&self.graph);",
			"        let ids = &scc.scc_ids;",
			"",
			"        for i in 0..self.n {",
			"            if ids[(i as usize) << 1] == ids[((i as usize) << 1) + 1] {",
			"                return None;",
			"            }",
			"            answer[i as usize] = ids[(i as usize) << 1] < ids[((i as usize) << 1) + 1];",
			"        }",
			"        Some(answer)",
			"    }",
			"}"
		],
		"prefix": "2sat"
	},
	"berlekamp": {
		"body": [
			"// Berlekamp-Massey",
			"// References",
			"// https://blog.naver.com/jinhan814/222140081932",
			"// https://koosaga.com/231",
			"",
			"fn rem_pow(mut base: i64, mut exp: i64, m: i64) -> i64 {",
			"    let mut result = 1;",
			"    while exp != 0 {",
			"        if exp & 1 != 0 {",
			"            result = (result * base) % m;",
			"        }",
			"        exp >>= 1;",
			"        base = (base * base) % m;",
			"    }",
			"    result",
			"}",
			"",
			"/// Finds rec[n] which satisfies",
			"/// vals[d] = rec[0]vals[0] + rec[1]vals[1] + ... + rec[d-1]vals[d-1]",
			"/// with minimum n.",
			"fn berlekamp_massey(vals: &[u64], m: u64) -> Vec<u64> {",
			"    let m = m as i64;",
			"    let mut cur: Vec<i64> = Vec::new();",
			"    let (mut lf, mut ld) = (0, 0);",
			"    let mut ls: Vec<i64> = Vec::new();",
			"    for i in 0..vals.len() {",
			"        let mut t = 0;",
			"        for (j, v) in cur.iter().enumerate() {",
			"            t = (t + vals[i - j - 1] as i64 * v) % m;",
			"        }",
			"",
			"        if (t - vals[i] as i64) % m == 0 {",
			"            continue;",
			"        }",
			"",
			"        if cur.len() == 0 {",
			"            cur = vec![0; i + 1];",
			"            lf = i;",
			"            ld = (t - vals[i] as i64) % m;",
			"            continue;",
			"        }",
			"",
			"        let k = -(vals[i] as i64 - t) * rem_pow(ld, m - 2, m) % m;",
			"        let mut c: Vec<i64> = vec![0; i - lf + ls.len()];",
			"        c[i - lf - 1] = k as i64;",
			"        for (p, j) in ls.iter().enumerate() {",
			"            c[i - lf + p] = -j * k % m;",
			"        }",
			"",
			"        if c.len() < cur.len() {",
			"            c.extend((0..(cur.len() - c.len())).map(|_| 0));",
			"        }",
			"",
			"        for j in 0..cur.len() {",
			"            c[j] = (c[j] + cur[j]) % m;",
			"        }",
			"",
			"        if i - lf + ls.len() >= cur.len() {",
			"            ls = cur;",
			"            lf = i;",
			"            ld = (t - vals[i] as i64) % m;",
			"        }",
			"",
			"        cur = c;",
			"    }",
			"",
			"    for i in 0..cur.len() {",
			"        cur[i] = (cur[i] % m + m) % m;",
			"    }",
			"",
			"    cur.into_iter().rev().map(|x| x as u64).collect()",
			"}"
		],
		"prefix": "berlekamp"
	},
	"bigint": {
		"body": [
			"mod bigint {",
			"    use std::{",
			"        fmt::Display,",
			"        num::ParseIntError,",
			"        ops::{Add, AddAssign, Mul, MulAssign, Sub, SubAssign},",
			"        str::FromStr,",
			"    };",
			"",
			"    const CHUNK: usize = 5;",
			"    const TENS: i64 = 100000;",
			"",
			"    #[derive(Clone, Default, Debug, PartialEq, Eq)]",
			"    pub struct Uint(Vec<i64>);",
			"",
			"    macro_rules! flatten {",
			"        (\\$uint:expr) => {",
			"            let mut carry: i64 = 0;",
			"            for i in 0..\\$uint.0.len() {",
			"                \\$uint.0[i] += carry;",
			"                carry = \\$uint.0[i].div_euclid(TENS);",
			"                \\$uint.0[i] -= carry * TENS;",
			"            }",
			"            while carry != 0 {",
			"                \\$uint.0.push(carry.rem_euclid(TENS));",
			"                carry = carry.div_euclid(TENS);",
			"            }",
			"            while let Some(&x) = \\$uint.0.last() {",
			"                if x != 0 {",
			"                    break;",
			"                }",
			"                \\$uint.0.pop();",
			"            }",
			"        };",
			"    }",
			"",
			"    macro_rules! impl_from_for_uint {",
			"        ($(\\$t:ty),*) => {",
			"            $(",
			"                impl From<\\$t> for Uint {",
			"                    fn from(x: \\$t) -> Self {",
			"                        let mut x = Self(vec![x as i64]);",
			"                        flatten!(x);",
			"                        x",
			"                    }",
			"                }",
			"            )*",
			"        };",
			"    }",
			"    impl_from_for_uint!(u8, u16, u32, u64, u128, usize);",
			"",
			"    impl FromStr for Uint {",
			"        type Err = ParseIntError;",
			"        fn from_str(s: &str) -> Result<Self, Self::Err> {",
			"            let s = s.trim_start_matches(\"0\");",
			"            if s.is_empty() {",
			"                return Ok(Self(vec![]));",
			"            }",
			"            let mut arr: Vec<i64> = Vec::with_capacity(s.len() / CHUNK + 2);",
			"            let mut s = s;",
			"            while s.len() > CHUNK {",
			"                let (l, r) = s.split_at(s.len() - CHUNK);",
			"                arr.push(r.parse()?);",
			"                s = l;",
			"            }",
			"            arr.push(s.parse()?);",
			"            Ok(Self(arr))",
			"        }",
			"    }",
			"",
			"    impl Display for Uint {",
			"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"            write!(f, \"{}\", *self.0.last().unwrap_or(&0))?;",
			"            for &v in self.0.iter().rev().skip(1) {",
			"                write!(f, \"{:0CHUNK$}\", v)?;",
			"            }",
			"            Ok(())",
			"        }",
			"    }",
			"",
			"    impl PartialOrd for Uint {",
			"        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
			"            use std::cmp::Ordering;",
			"            match self.0.len().cmp(&other.0.len()) {",
			"                Ordering::Equal => {",
			"                    for i in (0..self.0.len()).rev() {",
			"                        let x = self.0[i].cmp(&other.0[i]);",
			"                        if x != Ordering::Equal {",
			"                            return Some(x);",
			"                        }",
			"                    }",
			"                    Some(Ordering::Equal)",
			"                }",
			"                x => Some(x),",
			"            }",
			"        }",
			"    }",
			"",
			"    impl Ord for Uint {",
			"        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
			"            use std::cmp::Ordering;",
			"            match self.0.len().cmp(&other.0.len()) {",
			"                Ordering::Equal => {",
			"                    for i in (0..self.0.len()).rev() {",
			"                        let x = self.0[i].cmp(&other.0[i]);",
			"                        if x != Ordering::Equal {",
			"                            return x;",
			"                        }",
			"                    }",
			"                    Ordering::Equal",
			"                }",
			"                x => x,",
			"            }",
			"        }",
			"    }",
			"",
			"    impl AddAssign<&Uint> for Uint {",
			"        fn add_assign(&mut self, rhs: &Uint) {",
			"            if self.0.len() < rhs.0.len() {",
			"                for i in 0..self.0.len() {",
			"                    self.0[i] += rhs.0[i];",
			"                }",
			"                self.0.extend_from_slice(&rhs.0[self.0.len()..]);",
			"            } else {",
			"                for i in 0..rhs.0.len() {",
			"                    self.0[i] += rhs.0[i];",
			"                }",
			"            }",
			"",
			"            flatten!(self);",
			"        }",
			"    }",
			"",
			"    impl Add for &Uint {",
			"        type Output = Uint;",
			"        fn add(self, rhs: Self) -> Self::Output {",
			"            let mut c = self.clone();",
			"            c += rhs;",
			"            c",
			"        }",
			"    }",
			"",
			"    impl SubAssign<&Uint> for Uint {",
			"        fn sub_assign(&mut self, rhs: &Uint) {",
			"            // Panics if self.len() < rhs.len(): Think it as a underflow error",
			"            for (i, &v) in rhs.0.iter().enumerate() {",
			"                self.0[i] -= v;",
			"            }",
			"",
			"            flatten!(self);",
			"        }",
			"    }",
			"",
			"    impl Sub for &Uint {",
			"        type Output = Uint;",
			"        fn sub(self, rhs: Self) -> Self::Output {",
			"            let mut c = self.clone();",
			"            c -= rhs;",
			"            c",
			"        }",
			"    }",
			"",
			"    const NTT_THRES: usize = 5000;",
			"    const KARAT_THRES: usize = 30;",
			"",
			"    impl Mul for &Uint {",
			"        type Output = Uint;",
			"        fn mul(self, rhs: Self) -> Self::Output {",
			"            let max_len = self.0.len().max(rhs.0.len());",
			"            let max_2len = polymul::ceil_pow2(max_len);",
			"",
			"            // For performance reasons regarding vector copying, we determine whether to use",
			"            // NTT or not here.",
			"            let mut ans = Uint(if max_2len > NTT_THRES {",
			"                polymul::convolute(&self.0, &rhs.0)",
			"            } else {",
			"                let f: Vec<i64> = self",
			"                    .0",
			"                    .iter()",
			"                    .copied()",
			"                    .chain(std::iter::repeat(0))",
			"                    .take(max_2len)",
			"                    .collect();",
			"",
			"                let g: Vec<i64> = rhs",
			"                    .0",
			"                    .iter()",
			"                    .copied()",
			"                    .chain(std::iter::repeat(0))",
			"                    .take(max_2len)",
			"                    .collect();",
			"",
			"                polymul::mult_2pow(&f, &g)",
			"            });",
			"",
			"            flatten!(ans);",
			"            ans",
			"        }",
			"    }",
			"",
			"    impl MulAssign<&Uint> for Uint {",
			"        fn mul_assign(&mut self, rhs: &Uint) {",
			"            let x = &*self * rhs;",
			"            *self = x;",
			"        }",
			"    }",
			"",
			"    mod polymul {",
			"        pub fn ceil_pow2(n: usize) -> usize {",
			"            if n == 0 {",
			"                return 0;",
			"            }",
			"            let mut m = n;",
			"            while m != m & (!m + 1) {",
			"                m -= m & (!m + 1);",
			"            }",
			"            if n == m {",
			"                n",
			"            } else {",
			"                m * 2",
			"            }",
			"        }",
			"",
			"        pub fn mult_2pow(f: &[i64], g: &[i64]) -> Vec<i64> {",
			"            if f.len() > super::KARAT_THRES {",
			"                return karatsuba(f, g);",
			"            }",
			"",
			"            let mut ans = vec![0; 2 * f.len()];",
			"            for (i, &a) in f.iter().enumerate() {",
			"                for (j, &b) in g.iter().enumerate() {",
			"                    ans[i + j] += a * b;",
			"                }",
			"            }",
			"",
			"            ans",
			"        }",
			"",
			"        // Length of f = Length of g = 2n = 2^(k+1)",
			"        fn karatsuba(f: &[i64], g: &[i64]) -> Vec<i64> {",
			"            if f.len() == 1 {",
			"                return vec![f[0] * g[0]];",
			"            }",
			"            let n = f.len() / 2;",
			"            let k = n.trailing_zeros();",
			"            debug_assert_eq!(n, 1 << k);",
			"",
			"            let (fl, fr) = (&f[..n], &f[n..]);",
			"            let (gl, gr) = (&g[..n], &g[n..]);",
			"",
			"            let flgl = mult_2pow(fl, gl);",
			"            let frgr = mult_2pow(fr, gr);",
			"",
			"            let fsum: Vec<_> = fl.iter().zip(fr.iter()).map(|(&a, &b)| (a + b)).collect();",
			"            let gsum: Vec<_> = gl.iter().zip(gr.iter()).map(|(&a, &b)| (a + b)).collect();",
			"            let fsgs = mult_2pow(&fsum, &gsum);",
			"",
			"            let mut ans: Vec<_> = flgl.iter().copied().chain(frgr.iter().copied()).collect();",
			"            for i in 0..fsgs.len() {",
			"                ans[i + n] += fsgs[i];",
			"            }",
			"            for (i, v) in flgl",
			"                .iter()",
			"                .zip(frgr.iter())",
			"                .map(|(&a, &b)| (a + b))",
			"                .enumerate()",
			"            {",
			"                ans[i + n] -= v;",
			"            }",
			"",
			"            ans",
			"        }",
			"",
			"        const P2INV: i64 = 253522377;",
			"",
			"        pub fn convolute(a: &[i64], b: &[i64]) -> Vec<i64> {",
			"            let c1 = ntt1::convolute(a, b);",
			"            let c2 = ntt2::convolute(a, b);",
			"",
			"            c1.into_iter()",
			"                .zip(c2.into_iter())",
			"                .map(|(a1, a2)| {",
			"                    let j = ((a1 + ntt1::NTT_P as i64 - a2) * P2INV) % ntt1::NTT_P as i64;",
			"                    ntt2::NTT_P as i64 * j + a2",
			"                })",
			"                .collect()",
			"        }",
			"",
			"        // FFT_constname convention following https://algoshitpo.github.io/2020/05/20/fft-ntt/",
			"        macro_rules! impl_ntt {",
			"            (\\$modname:ident, \\$nttp:expr, \\$ntta:expr, \\$nttb:expr, \\$nttw:expr) => {",
			"                mod \\$modname {",
			"                    pub const NTT_P: u64 = \\$nttp;",
			"                    const NTT_A: u64 = \\$ntta;",
			"                    const NTT_B: u32 = \\$nttb;",
			"                    const NTT_W: u64 = \\$nttw;",
			"",
			"                    fn ceil_pow2(n: usize) -> usize {",
			"                        let mut x: usize = 0;",
			"                        while (1 << x) < n {",
			"                            x += 1;",
			"                        }",
			"                        x",
			"                    }",
			"",
			"                    pub fn convolute(a: &[i64], b: &[i64]) -> Vec<i64> {",
			"                        let nlen = 1 << ceil_pow2(a.len() + b.len());",
			"                        let mut arr = vec![0; nlen];",
			"                        let mut brr = vec![0; nlen];",
			"                        for (i, &a) in a.iter().enumerate() {",
			"                            arr[i] = a as u64;",
			"                        }",
			"                        for (i, &b) in b.iter().enumerate() {",
			"                            brr[i] = b as u64;",
			"                        }",
			"",
			"                        inplace_ntt(&mut arr);",
			"                        inplace_ntt(&mut brr);",
			"                        let mut crr: Vec<_> =",
			"                            arr.iter().zip(brr.iter()).map(|(&a, &b)| a * b).collect();",
			"                        inplace_intt(&mut crr);",
			"                        crr.iter().map(|&x| x as i64).collect()",
			"                    }",
			"",
			"                    #[inline(always)]",
			"                    fn rem_pow(mut base: u64, exp: u64) -> u64 {",
			"                        let mut result = 1u64;",
			"                        for exp in std::iter::successors(Some(exp), |x| Some(x >> 1))",
			"                            .take_while(|&v| v != 0)",
			"                        {",
			"                            if exp & 1 != 0 {",
			"                                result *= base;",
			"                                result %= NTT_P;",
			"                            }",
			"                            base *= base;",
			"                            base %= NTT_P;",
			"                        }",
			"                        result",
			"                    }",
			"",
			"                    // unity(n, 1) ** (1<<n) = 1",
			"                    fn unity(n: u32, k: u64) -> u64 {",
			"                        rem_pow(rem_pow(NTT_W, NTT_A), k << (NTT_B - n))",
			"                    }",
			"",
			"                    fn recip(x: u64) -> u64 {",
			"                        rem_pow(x, NTT_P - 2)",
			"                    }",
			"",
			"                    // Reverses k trailing bits of n",
			"                    fn reverse_trailing_bits(n: usize, k: u32) -> usize {",
			"                        let mut r: usize = 0;",
			"                        for i in 0..k {",
			"                            r |= ((n >> i) & 1) << (k - i - 1);",
			"                        }",
			"                        r",
			"                    }",
			"",
			"                    fn inplace_ntt(arr: &mut [u64]) {",
			"                        let n: usize = arr.len();",
			"                        let k = n.trailing_zeros();",
			"                        assert_eq!(n, 1 << k);",
			"",
			"                        for i in 0..n {",
			"                            let j = reverse_trailing_bits(i, k);",
			"                            if i < j {",
			"                                arr.swap(i, j);",
			"                            }",
			"                        }",
			"",
			"                        for x in 0..k {",
			"                            let base: u64 = unity(x + 1, 1);",
			"                            let s = 1 << x;",
			"                            for i in (0..n).step_by(s << 1) {",
			"                                let mut mult: u64 = 1;",
			"                                for j in 0..s {",
			"                                    let tmp = (arr[i + j + s] * mult) % NTT_P;",
			"                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;",
			"                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;",
			"                                    mult *= base;",
			"                                    mult %= NTT_P;",
			"                                }",
			"                            }",
			"                        }",
			"                    }",
			"",
			"                    fn inplace_intt(arr: &mut [u64]) {",
			"                        let n: usize = arr.len();",
			"                        let k = n.trailing_zeros();",
			"                        assert_eq!(n, 1 << k);",
			"",
			"                        for i in 0..n {",
			"                            let j = reverse_trailing_bits(i, k);",
			"                            if i < j {",
			"                                arr.swap(i, j);",
			"                            }",
			"                        }",
			"",
			"                        for x in 0..k {",
			"                            let base: u64 = recip(unity(x + 1, 1));",
			"                            let s = 1 << x;",
			"                            for i in (0..n).step_by(s << 1) {",
			"                                let mut mult: u64 = 1;",
			"                                for j in 0..s {",
			"                                    let tmp = (arr[i + j + s] * mult) % NTT_P;",
			"                                    arr[i + j + s] = (arr[i + j] + NTT_P - tmp) % NTT_P;",
			"                                    arr[i + j] = (arr[i + j] + tmp) % NTT_P;",
			"                                    mult *= base;",
			"                                    mult %= NTT_P;",
			"                                }",
			"                            }",
			"                        }",
			"",
			"                        let r = recip(n as u64);",
			"                        for f in arr.iter_mut() {",
			"                            *f *= r;",
			"                            *f %= NTT_P;",
			"                        }",
			"                    }",
			"                }",
			"            };",
			"        }",
			"",
			"        impl_ntt!(ntt1, 2281701377, 17, 27, 3);",
			"        impl_ntt!(ntt2, 998244353, 119, 23, 3);",
			"    }",
			"",
			"    #[derive(Clone, Copy, PartialEq, Eq, Debug)]",
			"    enum Sign {",
			"        Neg,",
			"        Pos, // Includes 0",
			"    }",
			"    use Sign::*;",
			"",
			"    #[derive(Clone, Debug, PartialEq, Eq)]",
			"    pub struct Int {",
			"        sign: Sign,",
			"        nat: Uint,",
			"    }",
			"",
			"    macro_rules! impl_from_for_int {",
			"        ($(\\$u:ty, \\$s:ty);*) => {",
			"            $(",
			"                impl From<\\$u> for Int {",
			"                    fn from(x: \\$u) -> Self {",
			"                        Self { sign: Pos, nat: x.into() }",
			"                    }",
			"                }",
			"                impl From<\\$s> for Int {",
			"                    fn from(x: \\$s) -> Self {",
			"                        if x < 0 {",
			"                            Self { sign: Neg, nat: ((-x) as \\$u).into() }",
			"                        } else {",
			"                            Self { sign: Pos, nat: (x as \\$u).into() }",
			"                        }",
			"                    }",
			"                }",
			"            )*",
			"        };",
			"    }",
			"",
			"    impl_from_for_int!(u8, i8; u16, i16; u32, i32; u64, i64; u128, i128; usize, isize);",
			"",
			"    impl FromStr for Int {",
			"        type Err = ParseIntError;",
			"        fn from_str(s: &str) -> Result<Self, Self::Err> {",
			"            if s.len() == 0 {",
			"                panic!(\"Empty string - TODO: Add a proper error propagation\");",
			"            }",
			"            let mut x = match s.strip_prefix(\"-\") {",
			"                Some(t) => Self {",
			"                    sign: Neg,",
			"                    nat: t.parse()?,",
			"                },",
			"                None => Self {",
			"                    sign: Pos,",
			"                    nat: s.parse()?,",
			"                },",
			"            };",
			"            if x.sign == Neg && x.nat.0.len() == 0 {",
			"                x.sign = Pos;",
			"            }",
			"            Ok(x)",
			"        }",
			"    }",
			"",
			"    impl Display for Int {",
			"        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
			"            if let Neg = self.sign {",
			"                write!(f, \"-\")?;",
			"            }",
			"            write!(f, \"{}\", self.nat)",
			"        }",
			"    }",
			"",
			"    impl PartialOrd for Int {",
			"        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
			"            use std::cmp::Ordering;",
			"            match (self.sign, other.sign) {",
			"                (Neg, Neg) => other.nat.partial_cmp(&self.nat),",
			"                (Neg, Pos) => Some(Ordering::Less),",
			"                (Pos, Neg) => Some(Ordering::Greater),",
			"                (Pos, Pos) => self.nat.partial_cmp(&other.nat),",
			"            }",
			"        }",
			"    }",
			"",
			"    impl Ord for Int {",
			"        fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
			"            use std::cmp::Ordering;",
			"            match (self.sign, other.sign) {",
			"                (Neg, Neg) => other.nat.cmp(&self.nat),",
			"                (Neg, Pos) => Ordering::Less,",
			"                (Pos, Neg) => Ordering::Greater,",
			"                (Pos, Pos) => self.nat.cmp(&other.nat),",
			"            }",
			"        }",
			"    }",
			"",
			"    impl AddAssign<&Int> for Int {",
			"        fn add_assign(&mut self, rhs: &Int) {",
			"            match (self.sign, rhs.sign) {",
			"                (Neg, Neg) => {",
			"                    self.nat += &rhs.nat;",
			"                }",
			"                (Neg, Pos) => {",
			"                    if self.nat >= rhs.nat {",
			"                        self.nat -= &rhs.nat;",
			"                    } else {",
			"                        let c = &rhs.nat - &self.nat;",
			"                        self.nat = c;",
			"                        self.sign = Pos;",
			"                    }",
			"                    if self.nat.0.len() == 0 {",
			"                        self.sign = Pos;",
			"                    }",
			"                }",
			"                (Pos, Neg) => {",
			"                    if self.nat >= rhs.nat {",
			"                        self.nat -= &rhs.nat;",
			"                    } else {",
			"                        let c = &rhs.nat - &self.nat;",
			"                        self.nat = c;",
			"                        self.sign = Neg;",
			"                    }",
			"                    if self.nat.0.len() == 0 {",
			"                        self.sign = Pos;",
			"                    }",
			"                }",
			"                (Pos, Pos) => {",
			"                    self.nat += &rhs.nat;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    impl Add for &Int {",
			"        type Output = Int;",
			"        fn add(self, rhs: Self) -> Self::Output {",
			"            let mut ans = self.clone();",
			"            ans += rhs;",
			"            ans",
			"        }",
			"    }",
			"",
			"    impl SubAssign<&Int> for Int {",
			"        fn sub_assign(&mut self, rhs: &Int) {",
			"            match (self.sign, rhs.sign) {",
			"                (Neg, Pos) => {",
			"                    self.nat += &rhs.nat;",
			"                }",
			"                (Neg, Neg) => {",
			"                    if self.nat >= rhs.nat {",
			"                        self.nat -= &rhs.nat;",
			"                    } else {",
			"                        let c = &rhs.nat - &self.nat;",
			"                        self.nat = c;",
			"                        self.sign = Pos;",
			"                    }",
			"                    if self.nat.0.len() == 0 {",
			"                        self.sign = Pos;",
			"                    }",
			"                }",
			"                (Pos, Pos) => {",
			"                    if self.nat >= rhs.nat {",
			"                        self.nat -= &rhs.nat;",
			"                    } else {",
			"                        let c = &rhs.nat - &self.nat;",
			"                        self.nat = c;",
			"                        self.sign = Neg;",
			"                    }",
			"                    if self.nat.0.len() == 0 {",
			"                        self.sign = Pos;",
			"                    }",
			"                }",
			"                (Pos, Neg) => {",
			"                    self.nat += &rhs.nat;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    impl Sub for &Int {",
			"        type Output = Int;",
			"        fn sub(self, rhs: Self) -> Self::Output {",
			"            let mut ans = self.clone();",
			"            ans -= &rhs;",
			"            ans",
			"        }",
			"    }",
			"",
			"    impl Mul for &Int {",
			"        type Output = Int;",
			"        fn mul(self, rhs: Self) -> Self::Output {",
			"            let x = &self.nat * &rhs.nat;",
			"            if x.0.len() == 0 || self.sign == rhs.sign {",
			"                Int { sign: Pos, nat: x }",
			"            } else {",
			"                Int { sign: Neg, nat: x }",
			"            }",
			"        }",
			"    }",
			"",
			"    impl MulAssign<&Int> for Int {",
			"        fn mul_assign(&mut self, rhs: &Int) {",
			"            let x = &self.nat * &rhs.nat;",
			"            self.nat = x;",
			"            if self.nat.0.len() == 0 || self.sign == rhs.sign {",
			"                self.sign = Pos;",
			"            } else {",
			"                self.sign = Neg;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"prefix": "bigint"
	},
	"bitpermutation": {
		"body": [
			"fn permutator_bit(bitcnt: u32, maxbit: u32) -> impl Iterator<Item = u64> {",
			"    let x = std::iter::successors(Some((1u64 << bitcnt) - 1), |&v| {",
			"        let t = v | (v - 1);",
			"        let u = (t + 1) | ((((!t) & (t + 1)) - 1) >> (v.trailing_zeros() + 1));",
			"        Some(u)",
			"    })",
			"    .take_while(move |&x| x < (1 << maxbit));",
			"    x",
			"}"
		],
		"prefix": "bitpermutation"
	},
	"bitset": {
		"body": [
			"struct BitArray {",
			"    bytes: Vec<u8>,",
			"}",
			"",
			"impl BitArray {",
			"    #[inline(always)]",
			"    fn new(size: usize) -> Self {",
			"        Self {",
			"            bytes: vec![0; (size >> 3) + 1],",
			"        }",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn get(&self, idx: usize) -> bool {",
			"        (self.bytes[idx >> 3] >> (idx & 0b111)) & 1 == 1",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn set_true(&mut self, idx: usize) {",
			"        self.bytes[idx >> 3] |= 1 << (idx & 0b111);",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn set_false(&mut self, idx: usize) {",
			"        self.bytes[idx >> 3] &= !(1 << (idx & 0b111));",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn set(&mut self, idx: usize, to: bool) {",
			"        if to {",
			"            self.set_true(idx);",
			"        } else {",
			"            self.set_false(idx);",
			"        }",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn toggle(&mut self, idx: usize) {",
			"        self.bytes[idx >> 3] ^= 1 << (idx & 0b111);",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn fill(&mut self, with: u8) {",
			"        for v in self.bytes.iter_mut() {",
			"            *v = with;",
			"        }",
			"    }",
			"",
			"    #[inline(always)]",
			"    fn fill_range(&mut self, chunk_start: usize, chunk_end: usize, with: u8) {",
			"        for v in self.bytes[chunk_start..chunk_end].iter_mut() {",
			"            *v = with;",
			"        }",
			"    }",
			"}"
		],
		"prefix": "bitset"
	},
	"bostanmori": {
		"body": [
			"/// Returns g, s, t s.t. g=gcd(a,b) and as+bt=r",
			"#[inline(always)]",
			"fn ext_gcd(a: i64, b: i64) -> (i64, i64, i64) {",
			"    let (mut s, mut old_s) = (0, 1);",
			"    let (mut r, mut old_r) = (b, a);",
			"    while r != 0 {",
			"        let q = old_r / r;",
			"",
			"        let new_r = old_r - q * r;",
			"        old_r = r;",
			"        r = new_r;",
			"",
			"        let new_s = old_s - q * s;",
			"        old_s = s;",
			"        s = new_s;",
			"    }",
			"",
			"    (",
			"        old_r,",
			"        old_s,",
			"        if b != 0 { (old_r - old_s * a) / b } else { 0 },",
			"    )",
			"}",
			"",
			"fn mod_inv(a: u64, m: u64) -> u64 {",
			"    let (_, mut x, _) = ext_gcd((a % m) as i64, m as i64);",
			"    if x < 0 {",
			"        x += m as i64;",
			"    }",
			"    x as u64 % m",
			"}",
			"",
			"/// f = f[0] + f[1]x + f[2]x2 + ...",
			"#[inline(always)]",
			"fn poly_mul(f: &[u64], g: &[u64], m: u64) -> Vec<u64> {",
			"    let mut h: Vec<u64> = vec![0; f.len() + g.len() - 1];",
			"    for (i, &u) in f.iter().enumerate() {",
			"        // u*x**i",
			"        for (j, &v) in g.iter().enumerate() {",
			"            // v*x**j",
			"            h[i + j] += u * v;",
			"            h[i + j] %= m;",
			"        }",
			"    }",
			"    while let Some(&v) = h.last() {",
			"        if v != 0 {",
			"            break;",
			"        }",
			"        h.pop();",
			"    }",
			"    h",
			"}",
			"",
			"#[inline(always)]",
			"fn poly_mul_even_order(f: &[u64], g: &[u64], m: u64) -> Vec<u64> {",
			"    let mut h: Vec<u64> = vec![0; (f.len() + g.len()) / 2 + 2];",
			"    for (i, &u) in f.iter().enumerate() {",
			"        if i & 1 == 0 {",
			"            for (j, &v) in g.iter().enumerate().step_by(2) {",
			"                h[(i + j) >> 1] += u * v;",
			"                h[(i + j) >> 1] %= m;",
			"            }",
			"        } else {",
			"            for (j, &v) in g.iter().enumerate().skip(1).step_by(2) {",
			"                h[(i + j) >> 1] += u * v;",
			"                h[(i + j) >> 1] %= m;",
			"            }",
			"        }",
			"    }",
			"    while let Some(&v) = h.last() {",
			"        if v != 0 {",
			"            break;",
			"        }",
			"        h.pop();",
			"    }",
			"    h",
			"}",
			"",
			"#[inline(always)]",
			"fn poly_mul_odd_order(f: &[u64], g: &[u64], m: u64) -> Vec<u64> {",
			"    let mut h: Vec<u64> = vec![0; (f.len() + g.len()) / 2 + 2];",
			"    for (i, &u) in f.iter().enumerate() {",
			"        if i & 1 != 0 {",
			"            for (j, &v) in g.iter().enumerate().step_by(2) {",
			"                h[(i + j) >> 1] += u * v;",
			"                h[(i + j) >> 1] %= m;",
			"            }",
			"        } else {",
			"            for (j, &v) in g.iter().enumerate().skip(1).step_by(2) {",
			"                h[(i + j) >> 1] += u * v;",
			"                h[(i + j) >> 1] %= m;",
			"            }",
			"        }",
			"    }",
			"    while let Some(&v) = h.last() {",
			"        if v != 0 {",
			"            break;",
			"        }",
			"        h.pop();",
			"    }",
			"    h",
			"}",
			"",
			"/// f(x) -> f(-x)",
			"#[inline(always)]",
			"fn get_neg_x(f: &[u64], m: u64) -> Vec<u64> {",
			"    f.iter()",
			"        .enumerate()",
			"        .map(|(i, &v)| if i & 1 == 0 { v } else { m - v })",
			"        .collect()",
			"}",
			"",
			"/// Finds arr[n] where",
			"/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]",
			"/// under modulo m where d=rec.len()=arr.len()",
			"fn bostan_mori(rec: &[u64], vals: &[u64], n: u64, m: u64) -> u64 {",
			"    if vals.len() as u64 > n {",
			"        return vals[n as usize];",
			"    }",
			"    let d = rec.len();",
			"",
			"    let mut q: Vec<u64> = Vec::with_capacity(d + 1);",
			"    q.push(1);",
			"    q.extend(rec.iter().map(|&v| m - v).rev());",
			"",
			"    let mut p = poly_mul(vals, &q, m);",
			"    p.truncate(d);",
			"",
			"    let mut n = n;",
			"    while n >= 1 {",
			"        let mq = get_neg_x(&q, m);",
			"        if n & 1 == 0 {",
			"            p = poly_mul_even_order(&p, &mq, m);",
			"        } else {",
			"            p = poly_mul_odd_order(&p, &mq, m);",
			"        }",
			"        q = poly_mul_even_order(&q, &mq, m);",
			"        n >>= 1;",
			"    }",
			"    p[0] * mod_inv(q[0], m) // Requires GCD(q[0], m) = 1, it's safe to have m as a prime",
			"}"
		],
		"prefix": "bostanmori"
	},
	"cartesianproduct": {
		"body": [
			"fn cart_prod<I, J, S, T>(a: I, b: J) -> impl Iterator<Item = (S, T)>",
			"where",
			"    I: Iterator<Item = S>,",
			"    J: Iterator<Item = T> + Clone,",
			"    S: Clone,",
			"{",
			"    a.flat_map(move |a| b.clone().map(move |b| (a.clone(), b)))",
			"}"
		],
		"prefix": "cartesianproduct"
	},
	"convexhull": {
		"body": [
			"#[derive(Clone, Debug, Eq, PartialEq)]",
			"struct Point {",
			"    x: i64,",
			"    y: i64,",
			"}",
			"",
			"impl Point {",
			"    fn add(&self, other: &Self) -> Self {",
			"        Self {",
			"            x: self.x + other.x,",
			"            y: self.y + other.y,",
			"        }",
			"    }",
			"    fn sub(&self, other: &Self) -> Self {",
			"        Self {",
			"            x: self.x - other.x,",
			"            y: self.y - other.y,",
			"        }",
			"    }",
			"}",
			"",
			"#[derive(Clone, Debug, Eq, PartialEq)]",
			"enum Turn {",
			"    CW,",
			"    CCW,",
			"    Zero,",
			"}",
			"",
			"fn get_turn(v1: &Point, v2: &Point) -> Turn {",
			"    let prod = v1.x * v2.y - v1.y * v2.x;",
			"    if prod > 0 {",
			"        Turn::CCW",
			"    } else if prod < 0 {",
			"        Turn::CW",
			"    } else {",
			"        Turn::Zero",
			"    }",
			"}",
			"",
			"fn compare_ccw(a: &Point, b: &Point) -> std::cmp::Ordering {",
			"    use std::cmp::Ordering;",
			"    if a == b {",
			"        return Ordering::Equal;",
			"    }",
			"    if a.x == 0 && a.y == 0 {",
			"        return Ordering::Less;",
			"    } else if b.x == 0 && b.y == 0 {",
			"        return Ordering::Greater;",
			"    }",
			"",
			"    let turn = get_turn(a, b);",
			"    if turn == Turn::CCW {",
			"        return Ordering::Less;",
			"    } else if turn == Turn::CW {",
			"        return Ordering::Greater;",
			"    }",
			"",
			"    let a_dist = a.x * a.x + a.y * a.y;",
			"    let b_dist = b.x * b.x + b.y * b.y;",
			"    a_dist.cmp(&b_dist)",
			"}",
			"",
			"fn convex_hull(arr: &mut [Point]) -> Vec<Point> {",
			"    let pivot = {",
			"        let mut pivot = Point {",
			"            x: i64::MAX,",
			"            y: i64::MAX,",
			"        };",
			"        for v in arr.iter() {",
			"            if pivot.y > v.y || (pivot.y == v.y && pivot.x > v.x) {",
			"                pivot.x = v.x;",
			"                pivot.y = v.y;",
			"            }",
			"        }",
			"        pivot",
			"    };",
			"",
			"    for v in arr.iter_mut() {",
			"        *v = v.sub(&pivot);",
			"    }",
			"",
			"    arr.sort_unstable_by(compare_ccw);",
			"",
			"    let mut stack = vec![arr[0].clone()];",
			"    let mut i = 1;",
			"    while i < arr.len() {",
			"        if stack.len() == 1 {",
			"            if arr[i] != stack[0] {",
			"                stack.push(arr[i].clone());",
			"            }",
			"            i += 1;",
			"            continue;",
			"        }",
			"",
			"        let a = &arr[i];",
			"        let b = &stack[stack.len() - 1];",
			"        let c = &stack[stack.len() - 2];",
			"        match get_turn(&b.sub(c), &a.sub(b)) {",
			"            Turn::CCW => {",
			"                stack.push(a.clone());",
			"                i += 1;",
			"            }",
			"            Turn::CW => {",
			"                stack.pop();",
			"            }",
			"            _ => {",
			"                stack.pop();",
			"                stack.push(a.clone());",
			"                i += 1;",
			"            }",
			"        }",
			"    }",
			"",
			"    for v in arr.iter_mut() {",
			"        *v = v.add(&pivot);",
			"    }",
			"    for v in stack.iter_mut() {",
			"        *v = v.add(&pivot);",
			"    }",
			"",
			"    stack",
			"}"
		],
		"prefix": "convexhull"
	},
	"crt": {
		"body": [
			"// Chinese remainder theorem",
			"// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/chinese_remainder.py",
			"",
			"fn gcd(x: i64, y: i64) -> i64 {",
			"    if y == 0 {",
			"        x",
			"    } else {",
			"        gcd(y, x % y)",
			"    }",
			"}",
			"",
			"/// Returns gcd(a, b), s, t s.t. a*s + b*t = gcd(a, b)",
			"#[inline(always)]",
			"fn ext_gcd(a: i64, b: i64) -> (i64, i64, i64) {",
			"    let (mut s, mut old_s) = (0, 1);",
			"    let (mut r, mut old_r) = (b, a);",
			"    while r != 0 {",
			"        let q = old_r / r;",
			"        let (new_r, new_s) = (old_r - q * r, old_s - q * s);",
			"        old_r = r; // Not using destructuring to support low version",
			"        r = new_r; // AtCoder is using 1.42.0",
			"        old_s = s;",
			"        s = new_s;",
			"    }",
			"",
			"    (",
			"        old_r,",
			"        old_s,",
			"        if b != 0 { (old_r - old_s * a) / b } else { 0 },",
			"    )",
			"}",
			"",
			"/// Returns x s.t. x=r_i (mod m_i) for all i",
			"fn crt(r: &[i64], m: &[i64]) -> Option<i64> {",
			"    let (mut x, mut m_prod) = (0, 1);",
			"    for (bi, mi) in r.iter().zip(m.iter()) {",
			"        let (g, s, _) = ext_gcd(m_prod, *mi);",
			"        if ((bi - x) % mi).rem_euclid(g) != 0 {",
			"            return None;",
			"        }",
			"        x += m_prod * ((s * ((bi - x).rem_euclid(*mi))).div_euclid(g));",
			"        m_prod = (m_prod * mi).div_euclid(gcd(m_prod, *mi));",
			"    }",
			"    Some(x.rem_euclid(m_prod))",
			"}"
		],
		"prefix": "crt"
	},
	"dijkstra": {
		"body": [
			"fn dijkstra<T: Copy + From<u8> + std::ops::Add<Output = T> + Eq + Ord>(",
			"    graph: &Graph<T>,",
			"    src: usize,",
			") -> Vec<Option<T>> {",
			"    use std::{cmp::Reverse, collections::BinaryHeap};",
			"    let mut dist: Vec<Option<T>> = vec![None; graph.n];",
			"    let mut heap: BinaryHeap<(Reverse<T>, usize)> = BinaryHeap::new();",
			"    heap.push((Reverse(0.into()), src));",
			"",
			"    while let Some((Reverse(curr_cost), curr)) = heap.pop() {",
			"        if dist[curr].map_or(false, |x| x < curr_cost) {",
			"            continue;",
			"        }",
			"        dist[curr] = Some(curr_cost);",
			"",
			"        for (next, &weight) in graph.neighbor(curr) {",
			"            let next_cost = curr_cost + weight;",
			"            if dist[next].map_or(true, |x| x > next_cost) {",
			"                dist[next] = Some(next_cost);",
			"                heap.push((Reverse(next_cost), next));",
			"            }",
			"        }",
			"    }",
			"",
			"    dist",
			"}"
		],
		"prefix": "dijkstra"
	},
	"dsu": {
		"body": [
			"struct UnionFind {",
			"    size: usize,",
			"    parents: Vec<usize>,",
			"    group_size: Vec<usize>,",
			"    group_num: usize,",
			"}",
			"",
			"impl UnionFind {",
			"    /// Returns a new UnionFind instance where `size` number of elements are in their own disjoint set.",
			"    fn new(size: usize) -> Self {",
			"        Self {",
			"            size,",
			"            parents: vec![size; size],",
			"            group_size: vec![1; size],",
			"            group_num: size,",
			"        }",
			"    }",
			"",
			"    /// Returns the number of nodes which can be reached from x.",
			"    fn get_group_size(&mut self, x: usize) -> usize {",
			"        let root = self.find_root(x);",
			"        self.group_size[root]",
			"    }",
			"",
			"    /// Returns the number of connected components.",
			"    fn get_group_num(&self) -> usize {",
			"        self.group_num",
			"    }",
			"",
			"    fn find_root(&mut self, x: usize) -> usize {",
			"        if self.parents[x] == self.size {",
			"            return x;",
			"        }",
			"        let root = self.find_root(self.parents[x]);",
			"        self.parents[x] = root;",
			"        root",
			"    }",
			"",
			"    /// Returns true if there exists a path from a to b.",
			"    fn is_reachable(&mut self, a: usize, b: usize) -> bool {",
			"        self.find_root(a) == self.find_root(b)",
			"    }",
			"",
			"    /// Add an edge between a and b.",
			"    fn union(&mut self, a: usize, b: usize) {",
			"        let a_root = self.find_root(a);",
			"        let b_root = self.find_root(b);",
			"",
			"        if a_root != b_root {",
			"            self.group_num -= 1;",
			"            let a_size = self.group_size[a_root];",
			"            let b_size = self.group_size[b_root];",
			"            if a_size < b_size {",
			"                self.parents[a_root] = b_root;",
			"                self.group_size[b_root] += a_size;",
			"            } else {",
			"                self.parents[b_root] = a_root;",
			"                self.group_size[a_root] += b_size;",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"prefix": "dsu"
	},
	"extgcd": {
		"body": [
			"// Extended Euclidean Algorithm",
			"// Reference: PyRival https://github.com/cheran-senthil/PyRival/blob/master/pyrival/algebra/gcd.py",
			"",
			"fn ext_gcd(a: i64, b: i64) -> (i64, i64, i64) {",
			"    let (mut s, mut old_s) = (0, 1);",
			"    let (mut g, mut old_g) = (b, a);",
			"    while g != 0 {",
			"        let q = old_g / g;",
			"        let (new_r, new_s) = (old_g - q * g, old_s - q * s);",
			"        old_g = g; // Not using destructuring to support low version",
			"        g = new_r; // AtCoder is using 1.42.0",
			"        old_s = s;",
			"        s = new_s;",
			"    }",
			"",
			"    (",
			"        old_g,",
			"        old_s,",
			"        if b != 0 { (old_g - old_s * a) / b } else { 0 },",
			"    )",
			"}"
		],
		"prefix": "extgcd"
	},
	"fastgraph": {
		"body": [
			"#[derive(Debug)]",
			"struct Graph<T> {",
			"    n: usize,",
			"    first: Vec<usize>,",
			"    edge: Vec<(usize, usize, T)>, // (to, prev, data)",
			"}",
			"",
			"impl<T> Graph<T> {",
			"    fn new(n: usize, e: usize) -> Self {",
			"        Self {",
			"            n,",
			"            first: vec![usize::MAX; n],",
			"            edge: Vec::with_capacity(e),",
			"        }",
			"    }",
			"",
			"    fn add_edge(&mut self, from: usize, to: usize, data: T) {",
			"        let prev = std::mem::replace(&mut self.first[from], self.edge.len());",
			"        self.edge.push((to, prev, data));",
			"    }",
			"",
			"    fn neighbor(&self, of: usize) -> Neighbor<T> {",
			"        Neighbor {",
			"            graph: self,",
			"            next_edge: self.first[of],",
			"        }",
			"    }",
			"}",
			"",
			"struct Neighbor<'g, T> {",
			"    graph: &'g Graph<T>,",
			"    next_edge: usize,",
			"}",
			"",
			"impl<'g, T> Iterator for Neighbor<'g, T> {",
			"    type Item = (usize, &'g T);",
			"",
			"    fn next(&mut self) -> Option<Self::Item> {",
			"        let (to, next_edge, data) = self.graph.edge.get(self.next_edge)?;",
			"        self.next_edge = *next_edge;",
			"        Some((*to, data))",
			"    }",
			"}"
		],
		"prefix": "fastgraph"
	},
	"fenwick": {
		"body": [
			"struct Fenwick<T> {",
			"    n: usize,",
			"    data: Vec<T>,",
			"}",
			"",
			"impl<T: Copy + From<i8> + std::ops::AddAssign + std::ops::Sub<Output = T>> Fenwick<T> {",
			"    fn new(n: usize) -> Self {",
			"        Self {",
			"            n,",
			"            data: vec![0.into(); n],",
			"        }",
			"    }",
			"",
			"    fn add(&mut self, idx: usize, val: T) {",
			"        let mut idx = idx + 1;",
			"        while idx <= self.n {",
			"            self.data[idx - 1] += val;",
			"            idx += idx & (!idx + 1);",
			"        }",
			"    }",
			"",
			"    fn get(&self, idx: usize) -> T {",
			"        self.sum(idx, idx + 1)",
			"    }",
			"",
			"    fn sum(&self, l: usize, r: usize) -> T {",
			"        self.inner_sum(r) - self.inner_sum(l)",
			"    }",
			"",
			"    fn inner_sum(&self, mut r: usize) -> T {",
			"        let mut s: T = 0.into();",
			"        while r > 0 {",
			"            s += self.data[r - 1];",
			"            r -= r & (!r + 1);",
			"        }",
			"        s",
			"    }",
			"}"
		],
		"prefix": "fenwick"
	},
	"gcd": {
		"body": [
			"fn gcd<T>(x: T, y: T) -> T",
			"where",
			"    T: Copy + PartialEq + PartialOrd + std::ops::Rem<Output = T> + From<u8>,",
			"{",
			"    if y == 0.into() {",
			"        x",
			"    } else {",
			"        let v = x % y;",
			"        gcd(y, v)",
			"    }",
			"}"
		],
		"prefix": "gcd"
	},
	"hashmap_macro": {
		"body": [
			"macro_rules! count_tts {",
			"    () => { 0 };",
			"    (\\$odd:tt $(\\$a:tt \\$b:tt)*) => { (count_tts!($(\\$a)*) << 1) | 1 };",
			"    ($(\\$a:tt \\$even:tt)*) => { count_tts!($(\\$a)*) << 1 };",
			"}",
			"",
			"// let map: HashMap<i64, i64> = hashmap![1,1; 2,2; 3,3];",
			"macro_rules! hashmap {",
			"    ($(\\$k:expr,\\$v:expr);*) => {{",
			"        let mut map = HashMap::with_capacity(count_tts![$(\\$k )*]);",
			"        $( map.insert(\\$k, \\$v); )*",
			"        map",
			"    }}",
			"}"
		],
		"prefix": "hashmap_macro"
	},
	"isqrt": {
		"body": [
			"fn isqrt<T>(s: T) -> T",
			"where",
			"    T: Copy",
			"        + std::ops::Shr<Output = T>",
			"        + std::ops::Add<Output = T>",
			"        + std::ops::Div<Output = T>",
			"        + PartialOrd",
			"        + From<u8>,",
			"{",
			"    let mut x0 = s >> 1.into();",
			"    if x0 != 0.into() {",
			"        let mut x1 = (x0 + s / x0) >> 1.into();",
			"        while x1 < x0 {",
			"            x0 = x1;",
			"            x1 = (x0 + s / x0) >> 1.into();",
			"        }",
			"        x0",
			"    } else {",
			"        s",
			"    }",
			"}"
		],
		"prefix": "isqrt"
	},
	"kitamasa": {
		"body": [
			"// Kitamasa",
			"// Reference: JusticeHui's Blog: <https://justicehui.github.io/hard-algorithm/2021/03/13/kitamasa/>",
			"",
			"fn poly_mul(v: &[u64], w: &[u64], rec: &[u64], m: u64) -> Vec<u64> {",
			"    let mut t = vec![0; 2 * v.len()];",
			"",
			"    for j in 0..v.len() {",
			"        for k in 0..w.len() {",
			"            t[j + k] += v[j] * w[k] % m;",
			"            if t[j + k] >= m {",
			"                t[j + k] -= m;",
			"            }",
			"        }",
			"    }",
			"",
			"    for j in (v.len()..2 * v.len()).rev() {",
			"        for k in 1..=v.len() {",
			"            t[j - k] += t[j] * rec[k - 1] % m;",
			"            if t[j - k] >= m {",
			"                t[j - k] -= m;",
			"            }",
			"        }",
			"    }",
			"",
			"    t[..v.len()].iter().map(|x| *x).collect()",
			"}",
			"",
			"/// Finds arr[n] where",
			"/// arr[n+d] = rec[0]arr[n] + rec[1]arr[n+1] + rec[2]arr[n+2] + rec[3]arr[n+3] + ... + rec[d-1]arr[n+d-1]",
			"/// under modulo m where d=rec.len()=arr.len()",
			"fn kitamasa(rec: &[u64], vals: &[u64], mut n: u64, m: u64) -> u64 {",
			"    let recurr: Vec<_> = rec.iter().rev().copied().collect();",
			"    let (mut s, mut t) = (vec![0u64; recurr.len()], vec![0u64; recurr.len()]);",
			"    s[0] = 1;",
			"    if recurr.len() != 1 {",
			"        t[1] = 1;",
			"    } else {",
			"        t[0] = recurr[0];",
			"    }",
			"",
			"    while n != 0 {",
			"        if n & 1 != 0 {",
			"            s = poly_mul(&s, &t, &recurr, m);",
			"        }",
			"        t = poly_mul(&t, &t, &recurr, m);",
			"        n >>= 1;",
			"    }",
			"",
			"    let mut ret = 0u64;",
			"    for i in 0..recurr.len() {",
			"        ret += s[i] * vals[i] % m;",
			"        if ret >= m {",
			"            ret -= m;",
			"        }",
			"    }",
			"    ret",
			"}"
		],
		"prefix": "kitamasa"
	},
	"kmp": {
		"body": [
			"struct KMPNeedle<'a, T: PartialEq> {",
			"    p: &'a [T],",
			"    c: Vec<usize>,",
			"}",
			"",
			"impl<'a, T: PartialEq> KMPNeedle<'a, T> {",
			"    fn new(p: &'a [T]) -> Self {",
			"        let mut c: Vec<usize> = vec![0; p.len() + 1];",
			"",
			"        let mut l = 0;",
			"        for (r, v) in p.iter().enumerate().skip(1) {",
			"            while l > 0 && p[l] != *v {",
			"                l = c[l];",
			"            }",
			"            if p[l] == *v {",
			"                c[r + 1] = l + 1;",
			"                l += 1;",
			"            }",
			"        }",
			"",
			"        Self { p, c }",
			"    }",
			"}",
			"",
			"struct KMPMatcher<'a, 'b: 'a, 'c: 'b, T: PartialEq> {",
			"    needle: &'c KMPNeedle<'b, T>,",
			"    t: &'a [T],",
			"    i: usize,",
			"    j: usize,",
			"}",
			"",
			"impl<'a, 'b: 'a, 'c: 'b, T: PartialEq> KMPMatcher<'a, 'b, 'c, T> {",
			"    fn new(needle: &'c KMPNeedle<'b, T>, t: &'a [T]) -> Self {",
			"        Self {",
			"            needle,",
			"            t,",
			"            i: 0,",
			"            j: 0,",
			"        }",
			"    }",
			"}",
			"",
			"impl<'a, 'b: 'a, 'c: 'b, T: PartialEq> Iterator for KMPMatcher<'a, 'b, 'c, T> {",
			"    type Item = usize;",
			"",
			"    fn next(&mut self) -> Option<Self::Item> {",
			"        while self.i < self.t.len() {",
			"            while self.j > 0 && self.t[self.i] != self.needle.p[self.j] {",
			"                self.j = self.needle.c[self.j];",
			"            }",
			"            if self.t[self.i] == self.needle.p[self.j] {",
			"                if self.j == self.needle.p.len() - 1 {",
			"                    self.j = self.needle.c[self.j + 1];",
			"                    self.i += 1;",
			"                    return Some(self.i - self.needle.p.len());",
			"                } else {",
			"                    self.j += 1;",
			"                }",
			"            }",
			"            self.i += 1;",
			"        }",
			"        None",
			"    }",
			"}"
		],
		"prefix": "kmp"
	},
	"lazyseg": {
		"body": [
			"fn ceil_pow2(n: usize) -> usize {",
			"    let mut x: usize = 0;",
			"    while (1 << x) < n {",
			"        x += 1;",
			"    }",
			"    x",
			"}",
			"",
			"/// Represents a monoid in a lazy segment tree $(S, \\cdot)$.",
			"trait Monoid {",
			"    fn opr(&self, other: &Self) -> Self;",
			"    fn e() -> Self;",
			"}",
			"",
			"/// Represents a map \\$F$ acting on the monoid $(S, \\cdot)$.",
			"trait Mapping<T: Monoid> {",
			"    fn map(&self, apply: &T) -> T;",
			"    fn compos(&self, other: &Self) -> Self;",
			"    fn id() -> Self;",
			"}",
			"",
			"/// Lazy segment tree for the monoid $(S, \\cdot)$ and the map \\$F$.",
			"struct LazySeg<S: Monoid, F: Mapping<S>> {",
			"    n: usize,",
			"    size: usize,",
			"    log: usize,",
			"    data: Vec<S>,",
			"    lazy: Vec<F>,",
			"}",
			"",
			"impl<S, F> LazySeg<S, F>",
			"where",
			"    S: Monoid + Clone,",
			"    F: Mapping<S> + Clone,",
			"{",
			"    fn update(&mut self, k: usize) {",
			"        self.data[k] = self.data[k << 1].opr(&self.data[(k << 1) + 1]);",
			"    }",
			"",
			"    fn all_apply(&mut self, k: usize, f: &F) {",
			"        self.data[k] = f.map(&self.data[k]);",
			"        if k < self.size {",
			"            self.lazy[k] = f.compos(&self.lazy[k]);",
			"        }",
			"    }",
			"",
			"    fn push(&mut self, k: usize) {",
			"        self.all_apply(k << 1, &self.lazy[k].clone());",
			"        self.all_apply((k << 1) + 1, &self.lazy[k].clone());",
			"        self.lazy[k] = F::id();",
			"    }",
			"",
			"    /// Initializes the lazy segment tree from the given array.",
			"    fn new(arr: &Vec<S>) -> Self {",
			"        let log = ceil_pow2(arr.len());",
			"        let mut ls: Self = LazySeg {",
			"            n: arr.len(),",
			"            log,",
			"            size: 1 << log,",
			"            data: vec![S::e(); 1 << (log + 1)],",
			"            lazy: vec![F::id(); 1 << log],",
			"        };",
			"        for (i, v) in arr.into_iter().enumerate() {",
			"            ls.data[ls.size + i] = (*v).clone();",
			"        }",
			"        for i in (1..ls.size).rev() {",
			"            ls.update(i);",
			"        }",
			"        ls",
			"    }",
			"",
			"    /// Sets a value at the index `i` to `v`.",
			"    fn set(&mut self, i: usize, v: &S) {",
			"        let i = i + self.size;",
			"        for j in (1..=self.log).rev() {",
			"            self.push(i >> j);",
			"        }",
			"        self.data[i] = v.clone();",
			"        for j in 1..=self.log {",
			"            self.update(i >> j);",
			"        }",
			"    }",
			"",
			"    /// Returns a reference to the value at the index `i`.",
			"    fn get(&mut self, i: usize) -> &S {",
			"        let i = i + self.size;",
			"        for j in (1..=self.log).rev() {",
			"            self.push(i >> j);",
			"        }",
			"        &self.data[i]",
			"    }",
			"",
			"    /// Returns a product of elements in [l, r).",
			"    fn prod(&mut self, l: usize, r: usize) -> S {",
			"        if l == r {",
			"            return S::e();",
			"        }",
			"",
			"        let (mut l, mut r) = (l + self.size, r + self.size);",
			"",
			"        for i in (1..=self.log).rev() {",
			"            if ((l >> i) << i) != l {",
			"                self.push(l >> i);",
			"            }",
			"            if ((r >> i) << i) != r {",
			"                self.push((r - 1) >> i);",
			"            }",
			"        }",
			"",
			"        let (mut sml, mut smr) = (S::e(), S::e());",
			"        while l < r {",
			"            if l & 1 == 1 {",
			"                sml = sml.opr(&self.data[l]);",
			"                l += 1;",
			"            }",
			"            if r & 1 == 1 {",
			"                r -= 1;",
			"                smr = self.data[r].opr(&smr);",
			"            }",
			"            l >>= 1;",
			"            r >>= 1;",
			"        }",
			"",
			"        sml.opr(&smr)",
			"    }",
			"",
			"    /// Returns the product of every elements.",
			"    fn all_prod(&self) -> S {",
			"        self.data[1].clone()",
			"    }",
			"",
			"    /// Apply a map `f` to the element at `i`.",
			"    fn apply(&mut self, i: usize, f: &F) {",
			"        let i = i + self.size;",
			"        for j in (1..=self.log).rev() {",
			"            self.push(i >> j);",
			"        }",
			"        self.data[i] = f.map(&self.data[i]);",
			"        for j in 1..=self.log {",
			"            self.update(i >> j);",
			"        }",
			"    }",
			"",
			"    /// Apply a map `f` to the element in an interval [l, r).",
			"    fn apply_range(&mut self, l: usize, r: usize, f: &F) {",
			"        if l == r {",
			"            return;",
			"        }",
			"",
			"        let (mut l, mut r) = (l + self.size, r + self.size);",
			"",
			"        for i in (1..=self.log).rev() {",
			"            if ((l >> i) << i) != l {",
			"                self.push(l >> i);",
			"            }",
			"            if ((r >> i) << i) != r {",
			"                self.push((r - 1) >> i);",
			"            }",
			"        }",
			"",
			"        let (l2, r2) = (l, r);",
			"        while l < r {",
			"            if l & 1 == 1 {",
			"                self.all_apply(l, f);",
			"                l += 1;",
			"            }",
			"            if r & 1 == 1 {",
			"                r -= 1;",
			"                self.all_apply(r, f);",
			"            }",
			"            l >>= 1;",
			"            r >>= 1;",
			"        }",
			"        l = l2;",
			"        r = r2;",
			"",
			"        for i in 1..=self.log {",
			"            if ((l >> i) << i) != l {",
			"                self.update(l >> i);",
			"            }",
			"            if ((r >> i) << i) != r {",
			"                self.update((r - 1) >> i);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    fn max_right<C: Fn(&S) -> bool>(&mut self, l: usize, g: C) -> usize {",
			"        if l == self.n {",
			"            return self.n;",
			"        }",
			"",
			"        let mut l = l + self.size;",
			"        for i in (1..=self.log).rev() {",
			"            self.push(l >> i);",
			"        }",
			"",
			"        let mut sm = S::e();",
			"        loop {",
			"            while l & 1 == 0 {",
			"                l >>= 1;",
			"            }",
			"            if !g(&sm.opr(&self.data[l])) {",
			"                while l < self.size {",
			"                    self.push(l);",
			"                    l <<= 1;",
			"                    if g(&sm.opr(&self.data[l])) {",
			"                        sm = sm.opr(&self.data[l]);",
			"                        l += 1;",
			"                    }",
			"                }",
			"                return l - self.size;",
			"            }",
			"            sm = sm.opr(&self.data[l]);",
			"            l += 1;",
			"",
			"            if l & ((!l) + 1) != l {",
			"                break;",
			"            }",
			"        }",
			"        self.n",
			"    }",
			"    ",
			"    fn min_left<C: Fn(&S) -> bool>(&mut self, r: usize, g: C) -> usize {",
			"        if r == 0 {",
			"            return 0;",
			"        }",
			"",
			"        let mut r = r + self.size;",
			"        for i in (1..=self.log).rev() {",
			"            self.push((r - 1) >> i);",
			"        }",
			"",
			"        let mut sm = S::e();",
			"        loop {",
			"            r -= 1;",
			"            while r > 1 && r & 1 == 1 {",
			"                r >>= 1;",
			"            }",
			"            if !g(&self.data[r].opr(&sm)) {",
			"                while r < self.size {",
			"                    self.push(r);",
			"                    r = (r << 1) + 1;",
			"                    if g(&self.data[r].opr(&sm)) {",
			"                        sm = self.data[r].opr(&sm);",
			"                        r -= 1;",
			"                    }",
			"                }",
			"                return r + 1 - self.size;",
			"            }",
			"            sm = self.data[r].opr(&sm);",
			"",
			"            if r & ((!r) + 1) == r {",
			"                break;",
			"            }",
			"        }",
			"        0",
			"    }",
			"}"
		],
		"prefix": "lazyseg"
	},
	"lcm": {
		"body": [
			"fn lcm<T>(x: T, y: T) -> T",
			"where",
			"    T: Copy",
			"        + PartialEq",
			"        + PartialOrd",
			"        + std::ops::Rem<Output = T>",
			"        + std::ops::Div<Output = T>",
			"        + std::ops::Mul<Output = T>",
			"        + From<u8>,",
			"{",
			"    x / gcd(x, y) * y",
			"}"
		],
		"prefix": "lcm"
	},
	"lislen": {
		"body": [
			"fn lis_len(arr: &[i64]) -> usize {",
			"    let mut table: Vec<i64> = vec![arr[0]];",
			"    for &v in arr[1..].iter() {",
			"        let p = table.partition_point(|&x| x < v);",
			"        if p == table.len() {",
			"            table.push(v);",
			"        } else {",
			"            table[p] = v;",
			"        }",
			"    }",
			"    table.len()",
			"}"
		],
		"prefix": "lislen"
	},
	"lisseq": {
		"body": [
			"fn lis(arr: &[i64]) -> Vec<i64> {",
			"    let n = arr.len();",
			"    let mut seq: Vec<i64> = Vec::with_capacity(n + 1);",
			"    seq.push(i64::MIN);",
			"    seq.extend(arr.iter().copied());",
			"",
			"    let mut back = vec![0usize; n + 1];",
			"    let mut table = vec![0usize];",
			"",
			"    for (i, &v) in seq.iter().enumerate().skip(1) {",
			"        let p = table.partition_point(|&x| seq[x] < v);",
			"        if p == table.len() {",
			"            table.push(i);",
			"        } else {",
			"            table[p] = i;",
			"        }",
			"        back[i] = table[p - 1];",
			"    }",
			"",
			"    let mut ptr = *table.last().unwrap();",
			"    let mut ans: Vec<i64> = Vec::with_capacity(table.len() - 1);",
			"    while ptr != 0 {",
			"        ans.push(seq[ptr]);",
			"        ptr = back[ptr];",
			"    }",
			"",
			"    ans.reverse();",
			"    ans",
			"}"
		],
		"prefix": "lisseq"
	},
	"manacher": {
		"body": [
			"fn manacher<T: Eq>(arr: &[T]) -> Vec<usize> {",
			"    let n = arr.len();",
			"    let mut mana: Vec<usize> = vec![1; n];",
			"    let mut r: usize = 1;",
			"    let mut p: usize = 0;",
			"",
			"    for i in 1..arr.len() {",
			"        if i + 1 >= r {",
			"            mana[i] = 1;",
			"        } else {",
			"            let j = 2 * p - i;",
			"            mana[i] = mana[j].min(r - i);",
			"        }",
			"",
			"        while mana[i] <= i && i + mana[i] < n {",
			"            if arr[(i - mana[i])] != arr[(i + mana[i])] {",
			"                break;",
			"            }",
			"            mana[i] += 1;",
			"        }",
			"",
			"        if r < mana[i] + i {",
			"            r = mana[i] + i;",
			"            p = i;",
			"        }",
			"    }",
			"",
			"    mana",
			"}"
		],
		"prefix": "manacher"
	},
	"matrix": {
		"body": [
			"struct Matrix<T>(Vec<T>, usize); // colnum",
			"",
			"impl<T> Matrix<T> {",
			"    fn new(arr: Vec<T>, r: usize, c: usize) -> Self {",
			"        assert_eq!(arr.len(), r * c);",
			"        Self(arr, c)",
			"    }",
			"}",
			"",
			"impl<T> std::ops::Index<usize> for Matrix<T> {",
			"    type Output = [T];",
			"",
			"    fn index(&self, i: usize) -> &Self::Output {",
			"        &self.0[self.1 * i..self.1 * (i + 1)]",
			"    }",
			"}",
			"",
			"impl<T> std::ops::IndexMut<usize> for Matrix<T> {",
			"    fn index_mut(&mut self, i: usize) -> &mut Self::Output {",
			"        &mut self.0[self.1 * i..self.1 * (i + 1)]",
			"    }",
			"}"
		],
		"prefix": "matrix"
	},
	"millerrabin": {
		"body": [
			"trait MillerRabin: From<u8> + PartialOrd {",
			"    const MR_THRES: Self;",
			"    fn naive_primality(self) -> bool;",
			"    fn miller_rabin_test(self, a: Self) -> bool;",
			"    fn miller_primality(self) -> bool;",
			"    fn is_prime(self) -> bool {",
			"        if self <= 1.into() {",
			"            false",
			"        } else if self <= Self::MR_THRES {",
			"            self.naive_primality()",
			"        } else {",
			"            self.miller_primality()",
			"        }",
			"    }",
			"}",
			"",
			"macro_rules! impl_millerrabin {",
			"        (\\$t:ty, \\$u:ty, \\$thres:expr, $(\\$x:expr),*) => {",
			"            impl MillerRabin for \\$t {",
			"                const MR_THRES: Self = \\$thres;",
			"",
			"                #[inline(always)]",
			"                fn naive_primality(self) -> bool {",
			"                    for i in (2..).take_while(|&i| i * i <= self) {",
			"                        if self % i == 0 {",
			"                            return false;",
			"                        }",
			"                    }",
			"                    true",
			"                }",
			"",
			"                #[inline(always)]",
			"                fn miller_rabin_test(self, a: Self) -> bool {",
			"                    let d = self - 1;",
			"                    let mut p = d >> (d.trailing_zeros());",
			"",
			"                    let mut t = {",
			"                        let mut base = a as \\$u;",
			"                        let mut exp = p as \\$u;",
			"                        let rem = self as \\$u;",
			"                        let mut ret: \\$u = 1;",
			"                        while exp != 0 {",
			"                            if exp & 1 != 0 {",
			"                                ret = ret * base % rem;",
			"                            }",
			"                            base = base*base%rem;",
			"                            exp >>= 1;",
			"                        }",
			"                        ret as \\$t",
			"                    };",
			"",
			"                    let at_last = t == d || t == 1;",
			"",
			"                    while p != d {",
			"                        p <<= 1;",
			"                        t = ((t as \\$u * t as \\$u) % self as \\$u) as \\$t;",
			"                        if t == self - 1 {",
			"                            return true;",
			"                        }",
			"                    }",
			"                    at_last",
			"                }",
			"",
			"                fn miller_primality(self) -> bool {",
			"                    $(",
			"                        if !self.miller_rabin_test(\\$x) {",
			"                            return false;",
			"                        }",
			"                    )*",
			"                    true",
			"                }",
			"            }",
			"        };",
			"    }",
			"",
			"impl_millerrabin!(u8, u16, 254, 2);",
			"impl_millerrabin!(u16, u32, 2000, 2, 3);",
			"impl_millerrabin!(u32, u64, 7000, 2, 7, 61);",
			"impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);"
		],
		"prefix": "millerrabin"
	},
	"mos": {
		"body": [
			"/// max_n: maximum number of l and r",
			"/// queries: Vec<(id, l, r)>",
			"fn mos_sort(max_n: u32, queries: &[(u32, u32, u32)]) -> Vec<&(u32, u32, u32)> {",
			"    let n_bit = ceil_pow_2(max_n + 1).trailing_zeros();",
			"    let mut arr: Vec<(u64, &(u32, u32, u32))> = queries.iter().map(|q| (0, q)).collect();",
			"    for q in arr.iter_mut() {",
			"        q.0 = hilbert_order(q.1 .1, q.1 .2, n_bit, 0);",
			"    }",
			"    arr.sort_unstable_by_key(|q| q.0);",
			"    arr.into_iter().map(|x| x.1).collect()",
			"}",
			"",
			"#[inline(always)]",
			"fn hilbert_order(x: u32, y: u32, pow: u32, rotate: u32) -> u64 {",
			"    if pow == 0 {",
			"        return 0;",
			"    }",
			"    let hpow: u32 = 1 << (pow - 1);",
			"    let mut seg: u32 = if x < hpow {",
			"        if y < hpow {",
			"            0",
			"        } else {",
			"            3",
			"        }",
			"    } else {",
			"        if y < hpow {",
			"            1",
			"        } else {",
			"            2",
			"        }",
			"    };",
			"    seg = (seg + rotate) & 3;",
			"",
			"    let (nx, ny) = (x & (x ^ hpow), y & (y ^ hpow));",
			"    let nrot = rotate + ROTATE_DELTA[seg as usize] & 3;",
			"    let sub_square_size = 1u64 << (2 * pow - 2);",
			"    let ans = seg as u64 * sub_square_size;",
			"    let add = hilbert_order(nx, ny, pow - 1, nrot);",
			"    if seg == 1 || seg == 2 {",
			"        ans + add",
			"    } else {",
			"        ans + sub_square_size - add - 1",
			"    }",
			"}",
			"",
			"const ROTATE_DELTA: [u32; 4] = [3, 0, 0, 1];",
			"",
			"#[inline(always)]",
			"fn ceil_pow_2(y: u32) -> u32 {",
			"    let mut x = y;",
			"    while x != (x & ((!x) + 1)) {",
			"        x -= x & ((!x) + 1);",
			"    }",
			"    if x == y {",
			"        x",
			"    } else {",
			"        x << 1",
			"    }",
			"}"
		],
		"prefix": "mos"
	},
	"pollardrho": {
		"body": [
			"trait PollardRho: MillerRabin + std::ops::ShrAssign + std::ops::BitAnd<Output = Self> + Clone {",
			"    fn rho(self, arr: &mut Vec<Self>, rng: &mut rng::RNG);",
			"    fn factorize(mut self, rng: &mut rng::RNG) -> Vec<Self> {",
			"        let mut arr: Vec<Self> = Vec::new();",
			"        if self <= 1.into() {",
			"            return arr;",
			"        }",
			"        while self.clone() & 1.into() == 0.into() {",
			"            self >>= 1.into();",
			"            arr.push(2.into());",
			"        }",
			"        self.rho(&mut arr, rng);",
			"        arr",
			"    }",
			"}",
			"",
			"macro_rules! impl_pollardrho {",
			"    (\\$t:ty, \\$u:ty, \\$reset:expr) => {",
			"        impl PollardRho for \\$t {",
			"            fn rho(self, arr: &mut Vec<Self>, rng: &mut rng::RNG) {",
			"                if self <= 1 {",
			"                    return;",
			"                } else if self.is_prime() {",
			"                    arr.push(self);",
			"                    return;",
			"                }",
			"",
			"                let mut i: u64 = 0;",
			"                let mut x: \\$t = (rng.next_u64() % self as u64) as \\$t;",
			"                let mut y: \\$t = x;",
			"                let mut k: u64 = 2;",
			"                let mut d: \\$t;",
			"                let mut reset_limit: u64 = \\$reset;",
			"",
			"                loop {",
			"                    i += 1;",
			"                    x = (((x as \\$u * x as \\$u % self as \\$u) + (self - 1) as \\$u) % self as \\$u) as \\$t;",
			"                    d = gcd(y.abs_diff(x), self);",
			"                    if d == self || i >= reset_limit {",
			"                        // Reset",
			"                        reset_limit = reset_limit * 3 / 2;",
			"                        i = 0;",
			"                        x = (rng.next_u64() % self as u64) as \\$t;",
			"                        y = x;",
			"                    }",
			"                    if d != 1 {",
			"                        break;",
			"                    }",
			"                    if i == k {",
			"                        y = x;",
			"                        k <<= 1;",
			"                    }",
			"                }",
			"",
			"                if d != self {",
			"                    d.rho(arr, rng);",
			"                    (self / d).rho(arr, rng);",
			"                    return;",
			"                }",
			"",
			"                let mut i = 3;",
			"                while i * i <= self {",
			"                    if self % i == 0 {",
			"                        i.rho(arr, rng);",
			"                        (d / i).rho(arr, rng);",
			"                        return;",
			"                    }",
			"                    i += 2;",
			"                }",
			"            }",
			"        }",
			"    };",
			"}",
			"",
			"impl_pollardrho!(u8, u16, 100000);",
			"impl_pollardrho!(u16, u32, 100000);",
			"impl_pollardrho!(u32, u64, 100000);",
			"impl_pollardrho!(u64, u128, 100000);",
			"",
			"trait MillerRabin: From<u8> + PartialOrd {",
			"    const MR_THRES: Self;",
			"    fn naive_primality(self) -> bool;",
			"    fn miller_rabin_test(self, a: Self) -> bool;",
			"    fn miller_primality(self) -> bool;",
			"    fn is_prime(self) -> bool {",
			"        if self <= 1.into() {",
			"            false",
			"        } else if self <= Self::MR_THRES {",
			"            self.naive_primality()",
			"        } else {",
			"            self.miller_primality()",
			"        }",
			"    }",
			"}",
			"",
			"macro_rules! impl_millerrabin {",
			"        (\\$t:ty, \\$u:ty, \\$thres:expr, $(\\$x:expr),*) => {",
			"            impl MillerRabin for \\$t {",
			"                const MR_THRES: Self = \\$thres;",
			"",
			"                #[inline(always)]",
			"                fn naive_primality(self) -> bool {",
			"                    for i in (2..).take_while(|&i| i * i <= self) {",
			"                        if self % i == 0 {",
			"                            return false;",
			"                        }",
			"                    }",
			"                    true",
			"                }",
			"",
			"                #[inline(always)]",
			"                fn miller_rabin_test(self, a: Self) -> bool {",
			"                    let d = self - 1;",
			"                    let mut p = d >> (d.trailing_zeros());",
			"",
			"                    let mut t = {",
			"                        let mut base = a as \\$u;",
			"                        let mut exp = p as \\$u;",
			"                        let rem = self as \\$u;",
			"                        let mut ret: \\$u = 1;",
			"                        while exp != 0 {",
			"                            if exp & 1 != 0 {",
			"                                ret = ret * base % rem;",
			"                            }",
			"                            base = base*base%rem;",
			"                            exp >>= 1;",
			"                        }",
			"                        ret as \\$t",
			"                    };",
			"",
			"                    let at_last = t == d || t == 1;",
			"",
			"                    while p != d {",
			"                        p <<= 1;",
			"                        t = ((t as \\$u * t as \\$u) % self as \\$u) as \\$t;",
			"                        if t == self - 1 {",
			"                            return true;",
			"                        }",
			"                    }",
			"                    at_last",
			"                }",
			"",
			"                fn miller_primality(self) -> bool {",
			"                    $(",
			"                        if !self.miller_rabin_test(\\$x) {",
			"                            return false;",
			"                        }",
			"                    )*",
			"                    true",
			"                }",
			"            }",
			"        };",
			"    }",
			"",
			"impl_millerrabin!(u8, u16, 254, 2);",
			"impl_millerrabin!(u16, u32, 2000, 2, 3);",
			"impl_millerrabin!(u32, u64, 7000, 2, 7, 61);",
			"impl_millerrabin!(u64, u128, 300000, 2, 325, 9375, 28178, 450775, 9780504, 1795265022);",
			"",
			"pub fn gcd<T>(x: T, y: T) -> T",
			"where",
			"    T: Copy + PartialEq + PartialOrd + std::ops::Rem<Output = T> + From<u8>,",
			"{",
			"    if y == 0.into() {",
			"        x",
			"    } else {",
			"        let v = x % y;",
			"        gcd(y, v)",
			"    }",
			"}",
			"",
			"mod rng {",
			"    pub struct RNG {",
			"        val: u64,",
			"    }",
			"    impl RNG {",
			"        pub fn new(seed: u64) -> Self {",
			"            Self { val: seed }",
			"        }",
			"        pub fn next_u64(&mut self) -> u64 {",
			"            let mut x = self.val;",
			"            x ^= x << 13;",
			"            x ^= x >> 7;",
			"            x ^= x << 17;",
			"            self.val = x;",
			"            x",
			"        }",
			"    }",
			"}"
		],
		"prefix": "pollardrho"
	},
	"psbase": {
		"body": [
			"fn main() {",
			"    // FastIO",
			"    use {fastio::*, std::io::*};",
			"    let input_str = get_input();",
			"    let mut sc: Splitter<_> = Splitter::new(input_str, |s| s.split_ascii_whitespace());",
			"    let stdout = stdout();",
			"    let wr = &mut BufWriter::new(stdout.lock());",
			"",
			"    // FastIO Macros",
			"    macro_rules! next {",
			"        () => { sc.next() };",
			"        ($(\\$t:ty) +) => { ($(sc.next::<\\$t>()),+) };",
			"    }",
			"    macro_rules! out { ($(\\$arg:tt)*) => { write!(wr, $(\\$arg)*).ok(); }; }",
			"    macro_rules! outln { ($(\\$arg:tt)*) => { writeln!(wr, $(\\$arg)*).ok(); }; }",
			"",
			"    // Main",
			"}",
			"",
			"mod fastio {",
			"    use std::{slice::*, str::*};",
			"",
			"    extern \"C\" {",
			"        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -> *mut u8;",
			"        fn fstat(fd: i32, stat: *mut usize) -> i32;",
			"    }",
			"",
			"    pub fn get_input() -> &'static str {",
			"        let mut stat = [0; 20];",
			"        unsafe { fstat(0, (&mut stat).as_mut_ptr()) };",
			"        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };",
			"        unsafe { from_utf8_unchecked(from_raw_parts(buffer, stat[6])) }",
			"    }",
			"",
			"    pub struct Splitter<I: Iterator> {",
			"        it: I,",
			"    }",
			"",
			"    impl<'a, 'b: 'a, T: Iterator> Splitter<T> {",
			"        pub fn new(s: &'b str, split: impl FnOnce(&'a str) -> T) -> Self {",
			"            Self { it: split(s) }",
			"        }",
			"    }",
			"",
			"    impl<'a, I: Iterator<Item = &'a str>> Splitter<I> {",
			"        pub fn next<T: FromStr>(&mut self) -> T {",
			"            self.it.next().unwrap().parse().ok().unwrap()",
			"        }",
			"        pub fn next_str(&mut self) -> &'a str {",
			"            self.it.next().unwrap()",
			"        }",
			"        pub fn next_opt<T: FromStr>(&mut self) -> Option<T> {",
			"            self.it.next().and_then(|s| s.parse().ok())",
			"        }",
			"        pub fn next_str_opt(&mut self) -> Option<&'a str> {",
			"            self.it.next()",
			"        }",
			"    }",
			"}"
		],
		"prefix": "psbase"
	},
	"psfast": {
		"body": [
			"#![no_main]",
			"",
			"#[no_mangle]",
			"fn main() -> i32 {",
			"    // FastIO",
			"    use {fastio::*, std::io::*};",
			"    let input_str = get_input();",
			"    let mut sc: Splitter<_> = Splitter::new(input_str, |s| s.split_ascii_whitespace());",
			"    let stdout = stdout();",
			"    let wr = &mut BufWriter::new(stdout.lock());",
			"",
			"    // FastIO Macros",
			"    macro_rules! next {",
			"        () => { sc.next() };",
			"        ($(\\$t:ty) +) => { ($(sc.next::<\\$t>()),+) };",
			"    }",
			"    macro_rules! out { ($(\\$arg:tt)*) => { write!(wr, $(\\$arg)*).ok(); }; }",
			"    macro_rules! outln { ($(\\$arg:tt)*) => { writeln!(wr, $(\\$arg)*).ok(); }; }",
			"",
			"    // Main",
			"",
			"    wr.flush().unwrap();",
			"    0",
			"}",
			"",
			"mod fastio {",
			"    use std::{slice::*, str::*};",
			"",
			"    #[link(name = \"c\")]",
			"    extern \"C\" {",
			"        fn mmap(addr: usize, len: usize, p: i32, f: i32, fd: i32, o: i64) -> *mut u8;",
			"        fn fstat(fd: i32, stat: *mut usize) -> i32;",
			"    }",
			"",
			"    pub fn get_input() -> &'static str {",
			"        let mut stat = [0; 20];",
			"        unsafe { fstat(0, (&mut stat).as_mut_ptr()) };",
			"        let buffer = unsafe { mmap(0, stat[6], 1, 2, 0, 0) };",
			"        unsafe { from_utf8_unchecked(from_raw_parts(buffer, stat[6])) }",
			"    }",
			"",
			"    pub struct Splitter<I: Iterator> {",
			"        it: I,",
			"    }",
			"",
			"    impl<'a, 'b: 'a, T: Iterator> Splitter<T> {",
			"        pub fn new(s: &'b str, split: impl FnOnce(&'a str) -> T) -> Self {",
			"            Self { it: split(s) }",
			"        }",
			"    }",
			"",
			"    impl<'a, I: Iterator<Item = &'a str>> Splitter<I> {",
			"        pub fn next<T: FromStr>(&mut self) -> T {",
			"            self.it.next().unwrap().parse().ok().unwrap()",
			"        }",
			"        pub fn next_str(&mut self) -> &'a str {",
			"            self.it.next().unwrap()",
			"        }",
			"        pub fn next_opt<T: FromStr>(&mut self) -> Option<T> {",
			"            self.it.next().and_then(|s| s.parse().ok())",
			"        }",
			"        pub fn next_str_opt(&mut self) -> Option<&'a str> {",
			"            self.it.next()",
			"        }",
			"    }",
			"}"
		],
		"prefix": "psfast"
	},
	"salcp": {
		"body": [
			"// Suffix array and LCP array",
			"// Reference: http://www.secmem.org/blog/2021/07/18/suffix-array-and-lcp/",
			"",
			"fn suffix_array<T: Ord>(s: &[T]) -> Vec<usize> {",
			"    use std::collections::*;",
			"",
			"    if s.len() == 0 {",
			"        return vec![];",
			"    } else if s.len() == 1 {",
			"        return vec![0];",
			"    }",
			"",
			"    let n = s.len();",
			"",
			"    let mut r: Vec<usize> = vec![0; n * 2];",
			"    let map: BTreeMap<_, _> = {",
			"        let mut sorted: Vec<_> = s.iter().collect();",
			"        sorted.sort_unstable();",
			"        sorted",
			"            .into_iter()",
			"            .enumerate()",
			"            .map(|x| (x.1, x.0 + 1))",
			"            .collect()",
			"    };",
			"    for i in 0..n {",
			"        r[i] = *map.get(&s[i]).unwrap();",
			"    }",
			"",
			"    let m = n.max(map.len()) + 1;",
			"    let mut sa: Vec<usize> = (0..n).collect();",
			"    let mut nr: Vec<usize> = vec![0; n * 2];",
			"    let mut cnt: Vec<usize> = vec![0; m];",
			"    let mut idx: Vec<usize> = vec![0; n];",
			"",
			"    for d in (0..).map(|x| 1 << x).take_while(|&d| d < n) {",
			"        macro_rules! key {",
			"            (\\$i:expr) => {",
			"                if \\$i + d >= n {",
			"                    (r[\\$i], 0)",
			"                } else {",
			"                    (r[\\$i], r[\\$i + d])",
			"                }",
			"            };",
			"        }",
			"",
			"        (0..m).for_each(|i| cnt[i] = 0);",
			"        (0..n).for_each(|i| cnt[r[i + d]] += 1);",
			"        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);",
			"        for i in (0..n).rev() {",
			"            cnt[r[i + d]] -= 1;",
			"            idx[cnt[r[i + d]]] = i;",
			"        }",
			"",
			"        (0..m).for_each(|i| cnt[i] = 0);",
			"        (0..n).for_each(|i| cnt[r[i]] += 1);",
			"        (1..m).for_each(|i| cnt[i] += cnt[i - 1]);",
			"        for i in (0..n).rev() {",
			"            cnt[r[idx[i]]] -= 1;",
			"            sa[cnt[r[idx[i]]]] = idx[i];",
			"        }",
			"",
			"        nr[sa[0]] = 1;",
			"        for i in 1..n {",
			"            nr[sa[i]] = nr[sa[i - 1]] + if key!(sa[i - 1]) < key!(sa[i]) { 1 } else { 0 };",
			"        }",
			"        std::mem::swap(&mut r, &mut nr);",
			"",
			"        if r[sa[n - 1]] == n {",
			"            break;",
			"        }",
			"    }",
			"",
			"    sa",
			"}",
			"",
			"fn sa_lcp<T: Ord>(arr: &[T]) -> (Vec<usize>, Vec<usize>) {",
			"    let n = arr.len();",
			"    let sa = suffix_array(arr);",
			"    let mut lcp: Vec<usize> = vec![0; n];",
			"    let mut isa: Vec<usize> = vec![0; n];",
			"    for i in 0..n {",
			"        isa[sa[i]] = i;",
			"    }",
			"    let mut k = 0;",
			"    for i in 0..n {",
			"        if isa[i] != 0 {",
			"            let j = sa[isa[i] - 1];",
			"            while i + k < n && j + k < n && arr[i + k] == arr[j + k] {",
			"                k += 1;",
			"            }",
			"            lcp[isa[i]] = if k != 0 {",
			"                k -= 1;",
			"                k + 1",
			"            } else {",
			"                0",
			"            };",
			"        }",
			"    }",
			"    (sa, lcp)",
			"}"
		],
		"prefix": "salcp"
	},
	"scc": {
		"body": [
			"#[derive(Debug)]",
			"struct Graph<T> {",
			"    n: u32,",
			"    first: Vec<u32>,",
			"    edge: Vec<(u32, u32, T)>, // (to, prev, data)",
			"}",
			"",
			"impl<T> Graph<T> {",
			"    fn new(n: u32, e: u32) -> Self {",
			"        Self {",
			"            n,",
			"            first: vec![u32::MAX; n as usize],",
			"            edge: Vec::with_capacity(e as usize),",
			"        }",
			"    }",
			"",
			"    fn add_edge(&mut self, from: u32, to: u32, data: T) {",
			"        let prev = std::mem::replace(&mut self.first[from as usize], self.edge.len() as u32);",
			"        self.edge.push((to, prev, data));",
			"    }",
			"",
			"    fn neighbor(&self, of: u32) -> Neighbor<T> {",
			"        Neighbor {",
			"            graph: self,",
			"            next_edge: self.first[of as usize],",
			"        }",
			"    }",
			"}",
			"",
			"struct Neighbor<'g, T> {",
			"    graph: &'g Graph<T>,",
			"    next_edge: u32,",
			"}",
			"",
			"impl<'g, T> Iterator for Neighbor<'g, T> {",
			"    type Item = (u32, &'g T);",
			"",
			"    fn next(&mut self) -> Option<Self::Item> {",
			"        let (to, next_edge, data) = self.graph.edge.get(self.next_edge as usize)?;",
			"        self.next_edge = *next_edge;",
			"        Some((*to, data))",
			"    }",
			"}",
			"",
			"struct SccStack {",
			"    stack: Vec<u32>,",
			"    check: Vec<bool>,",
			"}",
			"",
			"impl SccStack {",
			"    fn new(cap: u32) -> Self {",
			"        Self {",
			"            stack: vec![0; cap as usize],",
			"            check: vec![false; cap as usize],",
			"        }",
			"    }",
			"",
			"    fn len(&self) -> u32 {",
			"        self.stack.len() as u32",
			"    }",
			"",
			"    fn push(&mut self, n: u32) {",
			"        self.stack.push(n);",
			"        self.check[n as usize] = true;",
			"    }",
			"",
			"    fn get(&self) -> u32 {",
			"        self.stack[self.len() as usize - 1]",
			"    }",
			"",
			"    fn pop(&mut self) -> u32 {",
			"        let tmp = self.stack.pop().unwrap();",
			"        self.check[tmp as usize] = false;",
			"        tmp",
			"    }",
			"",
			"    fn is_in(&self, n: u32) -> bool {",
			"        self.check[n as usize]",
			"    }",
			"}",
			"",
			"struct SCC<'g, T> {",
			"    graph: &'g Graph<T>,",
			"    scc_list: Vec<Vec<u32>>,",
			"    scc_ids: Vec<u32>,",
			"}",
			"",
			"impl<'g, T: 'g> SCC<'g, T> {",
			"    fn new(graph: &'g Graph<T>) -> Self {",
			"        let mut st = SccStack::new(graph.n);",
			"        let mut list: Vec<Vec<u32>> = Vec::new();",
			"        let mut gid: u32 = 0;",
			"        let mut id = vec![graph.n; graph.n as usize];",
			"        let mut low = vec![u32::MAX; graph.n as usize];",
			"",
			"        for x in 0..graph.n {",
			"            if id[x as usize] != graph.n {",
			"                continue;",
			"            }",
			"            Self::dfs(graph, x, &mut gid, &mut id, &mut low, &mut st, &mut list)",
			"        }",
			"        list.reverse();",
			"",
			"        let mut ids = vec![0u32; graph.n as usize];",
			"        for (i, l) in list.iter().enumerate() {",
			"            for &v in l.iter() {",
			"                ids[v as usize] = i as u32;",
			"            }",
			"        }",
			"",
			"        Self {",
			"            graph,",
			"            scc_list: list,",
			"            scc_ids: ids,",
			"        }",
			"    }",
			"",
			"    fn dfs(",
			"        graph: &Graph<T>,",
			"        curr: u32,",
			"        gid: &mut u32,",
			"        id: &mut Vec<u32>,",
			"        low: &mut Vec<u32>,",
			"        st: &mut SccStack,",
			"        list: &mut Vec<Vec<u32>>,",
			"    ) {",
			"        st.push(curr);",
			"        id[curr as usize] = *gid;",
			"        low[curr as usize] = *gid;",
			"        (*gid) += 1;",
			"",
			"        for (next, _) in graph.neighbor(curr) {",
			"            if id[next as usize] == graph.n {",
			"                Self::dfs(graph, next, gid, id, low, st, list);",
			"            }",
			"        }",
			"",
			"        for (next, _) in graph.neighbor(curr) {",
			"            if st.is_in(next) {",
			"                low[curr as usize] = low[curr as usize].min(low[next as usize]);",
			"            }",
			"        }",
			"",
			"        if id[curr as usize] == low[curr as usize] {",
			"            let p = list.len();",
			"            list.push(Vec::new());",
			"            while st.len() != 0 && st.get() != curr {",
			"                list[p].push(st.pop());",
			"            }",
			"            st.pop();",
			"            list[p].push(curr);",
			"        }",
			"    }",
			"}"
		],
		"prefix": "scc"
	},
	"segtree": {
		"body": [
			"use std::ops::Index;",
			"",
			"fn ceil_pow2(n: usize) -> usize {",
			"    let mut x: usize = 0;",
			"    while (1 << x) < n {",
			"        x += 1;",
			"    }",
			"    x",
			"}",
			"",
			"/// Represents each element of a segment tree, which should be a monoid $(S, \\cdot)$.",
			"trait Monoid {",
			"    fn opr(&self, other: &Self) -> Self;",
			"    fn e() -> Self;",
			"}",
			"",
			"/// Segment tree.",
			"struct SegTree<S: Monoid> {",
			"    n: usize,",
			"    size: usize,",
			"    log: usize,",
			"    data: Vec<S>,",
			"}",
			"",
			"impl<S: Monoid + Clone> SegTree<S> {",
			"    fn update(&mut self, k: usize) {",
			"        self.data[k] = self.data[k << 1].opr(&self.data[(k << 1) + 1])",
			"    }",
			"",
			"    /// Initializes a segment tree from an array.",
			"    fn new(arr: &Vec<S>) -> Self {",
			"        let log = ceil_pow2(arr.len());",
			"        let mut st: Self = SegTree {",
			"            n: arr.len(),",
			"            log,",
			"            size: 1 << log,",
			"            data: vec![S::e(); 1 << (log + 1)],",
			"        };",
			"        for (i, v) in arr.into_iter().enumerate() {",
			"            st.data[st.size + i] = (*v).clone();",
			"        }",
			"        for i in (1..st.size).rev() {",
			"            st.update(i);",
			"        }",
			"        st",
			"    }",
			"",
			"    /// Sets a value at index `i` to a value `v`.",
			"    fn set(&mut self, i: usize, v: &S) {",
			"        let i = i + self.size;",
			"        self.data[i] = v.clone();",
			"        for j in 1..=self.log {",
			"            self.update(i >> j);",
			"        }",
			"    }",
			"",
			"    /// Gets a reference of a value at index `i`.",
			"    fn get(&self, i: usize) -> &S {",
			"        &self[i]",
			"    }",
			"",
			"    /// Returns \\$A_l \\cdot A_{l+1} \\cdot \\cdots \\cdot A_{r-1}$. If \\$l=r$, then returns \\$e$.",
			"    fn prod(&self, l: usize, r: usize) -> S {",
			"        let (mut sml, mut smr) = (S::e(), S::e());",
			"        let (mut l, mut r) = (l + self.size, r + self.size);",
			"",
			"        while l < r {",
			"            if l & 1 == 1 {",
			"                sml = sml.opr(&self.data[l]);",
			"                l += 1;",
			"            }",
			"            if r & 1 == 1 {",
			"                r -= 1;",
			"                smr = self.data[r].opr(&smr);",
			"            }",
			"            l >>= 1;",
			"            r >>= 1;",
			"        }",
			"        sml.opr(&smr)",
			"    }",
			"",
			"    /// Returns \\$A_0 \\cdot A_1 \\cdot \\cdots A_{n-1}$.",
			"    fn all_prod(&self) -> S {",
			"        self.data[1].clone()",
			"    }",
			"",
			"    fn max_right<C: Fn(&S) -> bool>(&self, l: usize, f: C) -> usize {",
			"        if l == self.n {",
			"            return self.n;",
			"        }",
			"",
			"        let mut l = l + self.size;",
			"        let mut sm = S::e();",
			"",
			"        loop {",
			"            while l & 1 == 0 {",
			"                l >>= 1;",
			"            }",
			"            if !f(&sm.opr(&self.data[l])) {",
			"                while l < self.size {",
			"                    l <<= 1;",
			"                    if f(&sm.opr(&self.data[l])) {",
			"                        sm = sm.opr(&self.data[l]);",
			"                        l += 1;",
			"                    }",
			"                }",
			"                return l - self.size;",
			"            }",
			"            sm = sm.opr(&self.data[l]);",
			"            l += 1;",
			"            if l & ((!l) + 1) == l {",
			"                break;",
			"            }",
			"        }",
			"        self.n",
			"    }",
			"    ",
			"    fn min_left<C: Fn(&S) -> bool>(&self, r: usize, f: C) -> usize {",
			"        if r == 0 {",
			"            return 0;",
			"        }",
			"",
			"        let mut r = r + self.size;",
			"        let mut sm = S::e();",
			"",
			"        loop {",
			"            r -= 1;",
			"            while r > 1 && r & 1 == 1 {",
			"                r >>= 1;",
			"            }",
			"            if !f(&self.data[r].opr(&sm)) {",
			"                while r < self.size {",
			"                    r = (r << 1) + 1;",
			"                    if f(&self.data[r].opr(&sm)) {",
			"                        sm = self.data[r].opr(&sm);",
			"                        r -= 1;",
			"                    }",
			"                }",
			"                return r + 1 - self.size;",
			"            }",
			"            sm = self.data[r].opr(&sm);",
			"",
			"            if r & ((!r) + 1) == r {",
			"                break;",
			"            }",
			"        }",
			"        0",
			"    }",
			"}",
			"",
			"impl<T: Monoid + Clone> Index<usize> for SegTree<T> {",
			"    type Output = T;",
			"",
			"    fn index(&self, index: usize) -> &Self::Output {",
			"        &self.data[index + self.size]",
			"    }",
			"}"
		],
		"prefix": "segtree"
	},
	"valuecompression": {
		"body": [
			"/// compressor[original_value] = compressed_value",
			"/// reevaluator[compressed_value] = original_value",
			"fn compress_value<T: Ord + std::hash::Hash>(",
			"    arr: &[T],",
			") -> (std::collections::HashMap<&T, usize>, Vec<&T>) {",
			"    use std::collections::*;",
			"    let compressor: HashMap<&T, usize> = {",
			"        let mut sorted: Vec<_> = arr.iter().collect();",
			"        sorted.sort_unstable();",
			"        sorted.dedup();",
			"        sorted.into_iter().enumerate().map(|x| (x.1, x.0)).collect()",
			"    };",
			"    let reevaluator: Vec<&T> = compressor.iter().map(|x| *x.0).collect();",
			"    (compressor, reevaluator)",
			"}"
		],
		"prefix": "valuecompression"
	},
	"zeroone": {
		"body": [
			"pub trait ZeroOne: Sized + Copy {",
			"    fn zero() -> Self;",
			"    fn one() -> Self;",
			"}",
			"",
			"macro_rules! impl_zero_one {",
			"    ($(\\$ty:ty) *) => { $(",
			"        impl ZeroOne for \\$ty {",
			"            #[inline(always)]",
			"            fn one() -> Self {1}",
			"            #[inline(always)]",
			"            fn zero() -> Self {0}",
			"        }",
			"    )+ };",
			"}",
			"",
			"impl_zero_one!(isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128);"
		],
		"prefix": "zeroone"
	}
}